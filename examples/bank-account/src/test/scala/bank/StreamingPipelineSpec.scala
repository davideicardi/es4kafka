package bank

import kaa.schemaregistry.SchemaRegistry
import kaa.schemaregistry.test.TestSchemaRegistry
import es4kafka.testing._
import es4kafka.serialization.CommonAvroSerdes._
import org.apache.kafka.streams.TopologyTestDriver
import org.scalamock.scalatest.MockFactory
import org.scalatest.funspec.AnyFunSpec
import org.scalatest.matchers.should.Matchers

class StreamingPipelineSpec extends AnyFunSpec with Matchers with MockFactory {
  implicit val schemaRegistry: SchemaRegistry = new TestSchemaRegistry

  private val target = new StreamingPipeline()

  describe("bank") {

    // I want to ensure that events generated by commands
    // are processed to construct the snapshots before the next commands.
    // This is important otherwise I can create new events from older snapshots.
    it("should process new commands after corresponding events") {
      runTopology { driver =>
        // commands
        val inOperations = new InputTopicTest[String, Operation](driver, Config.topicOperations)
        // events
        val outMovements = new OutputTopicTest[String, Movement](driver, Config.topicMovements)
        // snapshots
        val outAccounts = new OutputTopicTest[String, Account](driver, Config.topicAccounts)

        inOperations.pipeInput("alice", Operation(10))
        inOperations.pipeInput("alice", Operation(10))
        inOperations.pipeInput("alice", Operation(-20))

        outMovements.readValuesToSeq() should be (Seq(
          "alice" -> Movement(10),
          "alice" -> Movement(10),
          "alice" -> Movement(-20),
        ))

        outAccounts.readValuesToSeq() should be (Seq(
          "alice" -> Account(10),
          "alice" -> Account(20),
          "alice" -> Account(0),
        ))
      }
    }

    it("should not let account balance goes below 0") {
      runTopology { driver =>
        // commands
        val inOperations = new InputTopicTest[String, Operation](driver, Config.topicOperations)
        // events
        val outMovements = new OutputTopicTest[String, Movement](driver, Config.topicMovements)
        // snapshots
        val outAccounts = new OutputTopicTest[String, Account](driver, Config.topicAccounts)

        inOperations.pipeInput("alice", Operation(10))
        inOperations.pipeInput("alice", Operation(-20))

        outMovements.readValuesToSeq() should be (Seq(
          "alice" -> Movement(10),
          "alice" -> Movement(0, "insufficient funds"),
        ))

        outAccounts.readValuesToSeq() should be (Seq(
          "alice" -> Account(10),
        ))
      }
    }
  }

  def runTopology[T](testFun: TopologyTestDriver => T): T = {
    val topology = target.builder().build()
    val driver = new TopologyTestDriver(topology, Config.kafkaStreamProperties())

    try {
      testFun(driver)
    } finally {
      driver.close()
    }
  }
}
